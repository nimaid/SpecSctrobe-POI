#include <avr/pgmspace.h>
#define FHT_N 256
#define LIN_OUT 1
#include <FHT.h>
#include <Adafruit_NeoPixel.h>

//
// Spectrum analyzer
// Pete Reiter
// Spectrum analyzer with a Adafruit neopixel strip as output. Unlike an ordinary 2-dimensional spectrum
// analyzer that uses Y-axis is display intensity of each frequency band, this uses color and brightness of
// the LEDs to indicate the intensity. This code was originally adapted from the PICCOLO tiny music visualizer
// on the Adafruit web site.
// 
// Software requirements:
// - FHT library for Arduino
// - Adafruit Neopixel library.

#define PIN 6 // digital pin for programming neopixels
#define BRIGHT_PIN A1
#define NUM_PIXELS 16 // this is the size of my neopixel strip
#define SPACING_FACTOR 2.0 //Used to make bass larger.
//#define RMS_FACTOR 4.0 //use 2 for RMS, 3, for RMC, etc. Higher makes each channel more sensitive to single freqencies
#define GAIN_FACTOR 3 //higher means lower output values, a >> operation
#define OFF_THRESH 8 //higher clips lower amplitudes

Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_PIXELS, PIN, NEO_GRB + NEO_KHZ800);

// Microphone connects to Analog Pin 0.  Corresponding ADC channel number
// varies among boards...it's ADC0 on Uno and Mega, ADC7 on Leonardo.
// Other boards may require different settings; refer to datasheet.
#ifdef __AVR_ATmega32U4__
 #define ADC_CHANNEL 7
#else
 #define ADC_CHANNEL 0
#endif

volatile uint32_t samplePos = 0;     // Buffer position counter

static const uint8_t PROGMEM
  // This is low-level noise that's subtracted from each FHT output column
  // This was experimentally determined in a quiet room.
  noise[128]={ 
    50, 12, 10, 8, 7, 6, 6, 5, // 0
    5, 5, 4, 4, 4, 4, 4, 4,    // 8
    4, 4, 4, 4, 4, 4, 4, 4,    // 16
    4, 4, 4, 4, 4, 4, 4, 4,    // 24
    4, 4, 4, 4, 4, 4, 4, 4,    // 32
    3, 3, 3, 4, 3, 3, 3, 3,    // 40
    3, 3, 3, 3, 3, 3, 3, 3,    // 48    
    3, 3, 3, 3, 3, 3, 3, 3,    // 56
    3, 3, 3, 3, 3, 3, 3, 3,    // 64
    3, 3, 3, 3, 3, 3, 3, 3,    // 72
    3, 3, 3, 3, 3, 3, 3, 3,    // 80
    3, 3, 3, 3, 3, 3, 3, 3,    // 88
    3, 3, 3, 3, 3, 3, 3, 3,    // 96
    3, 3, 3, 3, 3, 3, 3, 3,    // 104
    3, 3, 3, 3, 3, 3, 3, 3,    // 112
    3, 3, 3, 3, 3, 3, 3, 3     // 120
};

static const uint8_t PROGMEM
  calibration[128] = {
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3,  
    3, 3, 3, 3, 3, 3, 3, 3,  
    3, 3, 3, 3, 3, 3, 3, 3,  
    3, 3, 3, 3, 3, 3, 3, 3  
  } ;

// This is the mapping from the values in the buckets to the colors representing those values. These numbers were generated by some C code that I've pasted into the bottom of this
// file. The colors go from off->blue->green->red with an increase in intensity as the values increase. There's also a log10 based response curve figured in.
#define NUM_COLORS 256
static const uint32_t PROGMEM colors[NUM_COLORS] = { 
0x0, 0x17, 0x2b, 0x3d, 0x4d, 0x5c, 0x55f, 0xc5c, 0x1458, 0x1b55, 0x2252, 0x294f, 0x2f4c, 0x3648, 0x3c45, 0x4242, 0x473f, 0x4d3b, 0x5238, 0x5735, 0x5d32, 0x612f, 0x662c, 0x6b29, 0x7026, 0x7424, 0x7821, 0x7c1e, 0x811b, 0x8518, 0x8916, 0x8d13, 0x9111, 0x950e, 0x980c, 0x9c09, 0xa007, 0xa305, 0xa702, 0xaa00, 0xacac00, 0xadab00, 0xaeaa00, 0xafa800, 0xb0a700, 0xb1a500, 0xb2a400, 0xb3a300, 0xb4a200, 0xb5a100, 0xb6a000, 0xb79e00, 0xb89e00, 0xb89c00, 0xb99b00, 0xba9a00, 0xbb9900, 0xbc9700, 0xbc9700, 0xbd9600, 0xbe9400, 0xbe9300, 0xbf9200, 0xc09100, 0xc19000, 0xc18f00, 0xc28d00, 0xc38c00, 0xc38b00, 0xc48a00, 0xc58900, 0xc58900, 0xc68800, 0xc68600, 0xc78500, 0xc88400, 0xc88300, 0xc98200, 0xc98100, 0xca8000, 0xca7f00, 0xcb7e00, 0xcc7d00, 0xcc7c00, 0xcd7b00, 0xcd7a00, 0xce7900, 0xce7800, 0xcf7700, 0xcf7600, 0xd07500, 0xd07400, 0xd17300, 0xd17300, 0xd27100, 0xd27100, 0xd36f00, 0xd36f00, 0xd36e00, 0xd46d00, 0xd46c00, 0xd56b00, 0xd56a00, 0xd66900, 0xd66800, 0xd76700, 0xd76700, 0xd76600, 0xd86400, 0xd86400, 0xd96300, 0xd96200, 0xd96100, 0xda6000, 0xda6000, 0xdb5f00, 0xdb5e00, 0xdb5d00, 0xdc5c00, 0xdc5b00, 0xdc5a00, 0xdd5a00, 0xdd5900, 0xde5800, 0xde5700, 0xde5600, 0xdf5500, 0xdf5500, 0xdf5400, 0xe05300, 0xe05200, 0xe05200, 0xe15100, 0xe15000, 0xe14f00, 0xe24e00, 0xe24e00, 0xe24d00, 0xe34c00, 0xe34b00, 0xe34b00, 0xe44a00, 0xe44900, 0xe44800, 0xe54700, 0xe54700, 0xe54600, 0xe64500, 0xe64400, 0xe64300, 0xe74300, 0xe74200, 0xe74200, 0xe74100, 0xe84000, 0xe83f00, 0xe83e00, 0xe93e00, 0xe93d00, 0xe93c00, 0xe93b00, 0xea3b00, 0xea3a00, 0xea3900, 0xeb3900, 0xeb3800, 0xeb3700, 0xeb3700, 0xec3600, 0xec3500, 0xec3400, 0xec3400, 0xed3400, 0xed3300, 0xed3200, 0xed3100, 0xee3000, 0xee3000, 0xee2f00, 0xee2e00, 0xef2d00, 0xef2e00, 0xef2d00, 0xef2c00, 0xf02b00, 0xf02b00, 0xf02a00, 0xf02900, 0xf12800, 0xf12800, 0xf12700, 0xf12600, 0xf22500, 0xf22600, 0xf22500, 0xf22400, 0xf32400, 0xf32300, 0xf32200, 0xf32200, 0xf32100, 0xf42000, 0xf42000, 0xf41f00, 0xf41e00, 0xf51d00, 0xf51d00, 0xf51c00, 0xf51b00, 0xf51b00, 0xf61b00, 0xf61b00, 0xf61a00, 0xf61900, 0xf71900, 0xf71800, 0xf71700, 0xf71700, 0xf71600, 0xf81500, 0xf81500, 0xf81400, 0xf81400, 0xf81300, 0xf91200, 0xf91200, 0xf91100, 0xf91000, 0xf91000, 0xfa0f00, 0xfa0f00, 0xfa0e00, 0xfa0d00, 0xfa0d00, 0xfb0c00, 0xfb0c00, 0xfb0b00, 0xfb0b00, 0xfb0a00, 0xfc0900, 0xfc0900, 0xfc0800, 0xfc0800, 0xfc0700, 0xfc0700, 0xfd0600, 0xfd0500, 0xfd0500, 0xfd0400, 0xfd0400, 0xfe0300, 0xfe0300, 0xfe0200, 0xfe0200, 0xfe0100, 0xff0100
}; 

#define THRESHOLD 1

int num_bins = (FHT_N/2) - 2;
int bins_per_group[NUM_PIXELS];

void setup() {
  Serial.begin(9600);  // set up Serial library at 9600 bps for debugging purposes
  
  //calc number of bins for each group
  float weights[NUM_PIXELS];
  for(int g = 0; g < NUM_PIXELS; g++)
  {
    //calc bins per group weight
    weights[g] = pow((float)g, SPACING_FACTOR) + 1;
  }
  float weight_sum = 0;
  for(int g = 0; g < NUM_PIXELS; g++)
  {
    //Serial.print(weights[g]);
    //Serial.print(' ');
    weight_sum += weights[g];
    //Serial.print(weight_sum);
    //Serial.print(' ');
  }
  //Serial.print('\n');
  //Serial.println(weight_sum);
  for(int g = 0; g < NUM_PIXELS; g++)
  {
    float percent = weights[g] / weight_sum;
    //Serial.print(percent * 100.0);
    //Serial.print(' ');
    float bins = (float)num_bins * percent;
    //Serial.print(bins);
    //Serial.print(' ');
    bins = round(bins);
    if((int)bins > 0)
    {
      bins_per_group[g] = (int)bins;
    }
    else
    {
      bins_per_group[g] = 1;
    }
    Serial.print(bins_per_group[g]);
    Serial.print(' ');
  }
  Serial.print('\n');
  
  pinMode(BRIGHT_PIN, INPUT);
  
  
  // The prescaler settings determine the frequency of audio sampling. We can sample higher
  // frequencies with a lower prescaler value, but it will also raise the lowest frequency that
  // we can sample.
  
  // Init ADC free-run mode; f = ( 16MHz/prescaler ) / 13 cycles/conversion 
  ADMUX  = ADC_CHANNEL; // Channel sel, right-adj, use AREF pin
  ADCSRA = _BV(ADEN)  | // ADC enable
           _BV(ADSC)  | // ADC start
           _BV(ADATE) | // Auto trigger
           _BV(ADIE)  | // Interrupt enable
           // select the prescaler value. Note that the max frequency our FFT will
           // display is half the sample rate.
//           _BV(ADPS2) | _BV(ADPS0); // 32:1 / 13 = 38,460 Hz
//           _BV(ADPS2) | _BV(ADPS1); // 64:1 / 13 = 19,230 Hz
           _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0); // 128:1 / 13 = 9615 Hz
  ADCSRB = 0;                // Free run mode, no high MUX bit
  DIDR0  = 1 << ADC_CHANNEL; // Turn off digital input for ADC pin
  TIMSK0 = 0;                // Timer0 off

  // Neopixels setup
  // Initialize all pixels to 'off'
  strip.setBrightness(255);
  strip.begin(); // Initialize all pixels to 'off'
  cli();         // disable interrupts when writing neopixels   
  strip.show();
  sei();         // Enable interrupts
  

}

void loop() {
  uint16_t  x, L;
  while(ADCSRA & _BV(ADIE)); // Wait for audio sampling to finish

  fht_window();
  fht_reorder();
  fht_run();
  fht_mag_lin();
  samplePos = 0;                   // Reset sample counter
  ADCSRA |= _BV(ADIE);             // Resume sampling interrupt

  
  // Remove noise
  for(x=0; x<FHT_N/2; x++) {
    L = (pgm_read_byte(&noise[x]) << 6);
    fht_lin_out[x] = (fht_lin_out[x] <= L) ? 0 : (fht_lin_out[x] - L);
  }
  
  
  int bin = 0;
  for (int i = 0; i < strip.numPixels(); i++)
  {
      // We will throw away first 2 regardless (garbage data TBH), so we will use 126, or index 2 to index 127
      // We will lose some bins in the high end as well.
      // We use RMS instead of mean because higher frequencies are more squished together
      float  mean_square = 0;
      for (int j = 0; j < bins_per_group[i]; j++)
      {
        mean_square += (pow(fht_lin_out[bin + 2], 2.0) - mean_square) / (i + 1);
        if(bin + 2 < num_bins)
        {
          bin ++;
        }
      }
      int value = round(sqrt(mean_square));

      value >>= GAIN_FACTOR;
      if (value < OFF_THRESH)
        value = 0;
      if (value >= NUM_COLORS)
        value = NUM_COLORS - 1;      
      strip.setPixelColor(i, pgm_read_dword(&colors[value]));
  }
  cli();        // no interrupts while writing the neopixels
  //strip.setBrightness(analogRead(BRIGHT_PIN));
  strip.show();
  sei();        // restore interrupts
}

// interrupt service routine. This gets called each time the ADC finishes 1 sample.
ISR(ADC_vect) { // Audio-sampling interrupt
  // shift the unsigned input to be centered around 0. The 10-bit ADC is 
  // capable of producing values from 0 - 1023, but with a microphone that outputs
  // 2V max and a reference voltage of 3.3V we will never hit the max.
  fht_input[samplePos] = (ADC - 512) << 6;
//  Serial.println(fht_input[samplePos]);
  if(++samplePos >= FHT_N) ADCSRA &= ~_BV(ADIE); // Buffer full, interrupt off
}

/*
// Some C code I used to generate the values->colors map. I didn't run this code on the Arduino. I used ideone.com
// and then pasted the output into my arduino code.
#include <iostream>
#include <stdint.h>
#include <math.h>
using namespace std;
  
const int numValues = 256; // number of colors in our output array. This should correspond 
                          // to the max value you want to display.

double breakPoint = log10(numValues)/3.0;
//double breakPoint = numValues/4.0;
//
// Blend two colors together based on the ratio. ratio of 0.0 will be 100% color a and
// ratio of 1.0 will be 100% color b.
uint32_t blend (uint32_t ina, uint32_t inb, double ratio)
{
  int r = (((ina >> 16) & 0xff) * (1.0-ratio)) + (((inb >> 16) & 0xff) * ratio);
  int g = (((ina >> 8) & 0xff) * (1.0-ratio)) + (((inb >> 8) & 0xff) * ratio);
  int b = (((ina >> 0) & 0xff) * (1.0-ratio)) + (((inb >> 0) & 0xff) * ratio);
  return ((r << 16) | (g << 8) | b);
}
//
// Scale the intensity of the passed in color. I am using max brightness colors and 
// 0.0 - 1.0 as the scale value.
uint32_t scale (uint32_t ina, double scale_value)
{
  int r = ((ina >> 16) & 0xff) * scale_value;
  int g = ((ina >> 8) & 0xff) * scale_value;
  int b = ((ina >> 0) & 0xff) * scale_value;
  return ((r << 16) | (g << 8) | b);  
}
//  
// Fade off -> blue -> green -> red. I've built in a logarithmic response to make it more of a
// dB meter.
int main() { 
  for (int i = 1; i <= numValues; i++)
  {
    double logValue = log10(i);
    double scaleValue = log10(i+2) / log10(numValues+2);
    //double logValue = i;
    //double scaleValue = i+2 / numValues+2;
    double ratio = (logValue < breakPoint) ? logValue / breakPoint : (logValue - breakPoint) / breakPoint;
    uint32_t color = 0;
    if (logValue < breakPoint)
      color = blend (0x000000, 0x00ff, ratio);
    else if (logValue < breakPoint * 2)
      color = blend (0x0000ff, 0x00ff00, ratio);
    else
      color = blend (0x00ff00, 0xff0000, ratio);
    color = scale (color, scaleValue);
    cout <<  "0x" << hex << color << ", ";
  }
  return 0; 
}
*/